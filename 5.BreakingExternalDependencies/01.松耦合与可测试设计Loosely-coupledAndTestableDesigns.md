# 松耦合与可测试设计 Loosely-coupled And Testable Designs
本篇记录了松耦合与可测试设计之间的关系

### 松耦合设计与测试的关系是什么？
只有松耦合结构的代码才具备可测试性。在实际情况中，项目可能继承大量多年前的代码，这些代码在编写的过程中可能没有考虑到会进行单元测试，导致无法对其进行单元测试。如果想单元测试这些"遗产代码"，就需要将这些代码重构，使其具备可测试性。

### 为什么只有松耦合结构的代码才可测试？
紧耦合代码不符合单元测试的基本条件，即单元测试对象必须为隔离状态，不能与外部资源有联系。遇到必须与外部资源有联系的方法，紧耦合结构就直接丧失可测试性。而松耦合结构代码可以通过在运行时将外部资源对象替换成一个空壳对象，达到不真正与外部资源联系的目的，从而具备可测试性。这种空壳对象被称为**假对象(Fake Object)或测试替身(Test Double)**。

### 如何才能将远古代码重构成符合松耦合设计标准并具备可测试性？
只需跟随简单三步走:

1. 将涉及到与外部资源沟通的代码部分抽取出来，放在一个新建的单独类中，达到将受测类/方法隔离的目的
2. 从刚新建的单独类中抽取一个接口并让这个类执行这个接口
3. 将这个接口注入到原受测类中

以上，即可将遗产代码重构为松耦合结构并具备可测试性。举一个简单例子:
受测类中有一个方法`MyMethod()`代码如下：
```c#
        public void MyMethod()
        {
            var reader = new FileReader();    //在第一步中应该删掉这部分代码，解耦
            reader.Read();
        }
```
这是一个紧耦合结构的代码，因为其中`var reader = new FileReader();`实例化了`FileReader`类，即与外部资源`FileReader`类产生了强依赖关系。根据解耦步骤，首先将这部分代码抽取出来，放到一个新类新方法中。但此处仅仅为实例化了`FileReader`类，没有包括其他方法，意味着不用再新建一个类，直接从`FileReader`类中抽取接口并执行这个接口，代码如下：
```c#
    public Interface IFileReader    //抽取接口
    {
        string Read();
    }

    public class FileReader : IFileReader   //执行IFileReader接口
    {
        public string Read()
        {
            //Implementation
        }
    }
```
最后，在删除了原代码中的实例化类部分后，直接在参数中注入接口，代码如下:
```c#
        public void MyMethod(IFileReader reader)
        {
            reader.Read();
        }
```
如此，只用在方法参数中传入任何带有`IFileReader`接口的实例都能让程序正确运行，而不仅限于传入`FileReader`类的实例。

解耦完成。

### 如何将接口注入到原受测类中？
有三种注入方式:

* 通过方法参数注入
* 通过类中属性注入
* 通过类中构造器注入

上例中的注入方式属于方法参数注入。通过以上任意方式注入接口到受测类/方法中，可以达到解耦的目的，即将依赖关系从紧密依赖某一具体类改成依赖所有执行了某一接口的类，因此这种注入方式也称为**依赖注入**。以上三种方式在接下来会有更详细的记录。
