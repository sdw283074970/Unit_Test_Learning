# 通过构造器依赖注入 Dependency Injection via Constructor
本片记录了通过构造器进行依赖注入的方法

### 什么是通过构造器依赖注入？
之前通过属性依赖注入有用到构造器，但其只用到了构造器赋值的功能。使用构造器进行依赖注入可以说是通过参数、属性依赖注入的合体版，即在受测类中建立一个**私有属性**，然后通过构造器参数为这个**私有属性**赋值。其代码如下:
```c#
    public class VideoService
    {
        private IFileReader _fileReader;

        public VideoService(IFileReader fileReader)     //通过构造器注入依赖对象
        {
            _fileReader = fileReader;       //将注入的依赖对象赋值给当前类中的私有属性
        }

        public string ReadVideoTitle()
        {
            var str = _fileReader.Read("Video.txt");        //直接调用私有属性
            var video = JsonConvert.DeserializeObject<Video>(str);
            if (video == null)
                return "Error parsing the video.";
            return video.Title;
        }
    }
```
如此重构代码有一个大问题。即，添加了构造器的签名会造成产品代码中已经实例化这个类的代码断裂，因为原本的构造器是没有额外签名的。解决已存在代码断裂问题的方案也很简单，即添加构造器重载，而不是直接修改构造器。其代码如下:
```c#
    public class VideoService
    {
        private IFileReader _fileReader;

        public VideoService()       //保留原的空签名构造器
        {
            _fileReader = new FileReader();     //保留原来注入的固定对象
        }

        public VideoService(IFileReader fileReader)     //添加有依赖注入签名的构造器重载
        {
            _fileReader = fileReader;       //将依赖对象赋值给当前类中的私有属性
        }

        public string ReadVideoTitle()
        {
            var str = _fileReader.Read("Video.txt");
            var video = JsonConvert.DeserializeObject<Video>(str);
            if (video == null)
                return "Error parsing the video.";
            return video.Title;
        }
    }
```
甚至可以将两个构造器重载合并为同一个。合并后的构造器代码如下:
```c#
        public VideoService(IFileReader fileReader == null)     //将依赖对象初始化为空
        {
            _fileReader = fileReader ?? new FileReader();       //在赋值前判断依赖对象是否为空。若不为空，直接赋值；若为空，则赋值为固定对象new FileReader()
        }
```
至此代码重构完成，解耦成功。

### 如何测试这种解耦的类/方法?
在调用方法中传入`测试替身`即可。以上类/方法的测试代码如下:
```c#

```
