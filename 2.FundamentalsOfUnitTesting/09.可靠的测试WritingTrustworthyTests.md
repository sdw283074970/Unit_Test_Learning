# 可靠的测试 Writing Trustworthy Tests
本篇记录了如何才能写出可靠测试的方法

### 怎样才算是是一个可靠的测试？
可靠测试是一个我们可以信任、依赖的测试。如果测试通过，则说明产品代码没有问题，反之则说明什么地方出了问题。

### 怎样才能写出一个可靠的测试？
有两个方法：
1. 使用测试驱动开发(TDD)。由于其是测试驱动开发，则写出的测试一定是可靠测试
2. 确保测试方法测试的是"想要测试的部分"

### 什么是不可靠测试？
不可靠测试指即使测试通过，产品代码也可能有问题。如果测试到不正确的部分会导致这个情况。如以下情况:
```c#
        [Test]
        [TestCase(2, 1, 2)]
        [TestCase(2, 3, 3)]
        [TestCase(2, 2, 2)]
        public void Max_WhenCalled_ReturnTheGreaterArgument(int a, int b, int expect)
        {
            var result = _math.Max(a, b);

            Assert.That(_math, Is.Not.Null);
        }
```
以上测试为测试`Max()`方法是否能返回最大值。但断言方法判定通过测试的标准不是`expect`值而是`_math`是否为空，那么结果显而易见，即这个测试是总是通过。但问题是，这个测试并不以`Max()`方法的功能为标准，即有可能`Max()`代码有问题，但测试总是通过。这就是一个不可靠测试，可以说断言方法测错了地方。

### 怎样能确保断言方法是测试的产品代码中正确的部分？
判断是否测对地方的方法很简单，分两种情况。即当测试方法写好并通过后，返回受测方法，改变或删除想要测试的关键句，再运行一次测试，观察测试结果。如果测试仍然通过，则说明断言方法测错地方了；如果测试通过，则说明测的地方正确，按情况可以适量缩小范围，反复测试。

继续以上例为例，用以上的判断方法证明上例断言方法测错了位置。

打开`Max()`方法，修改`Max()`方法的功能，使其理论上不应该通过测试。代码如下：
```c#
        public int Max(int a, int b)
        {
            //return (a > b) ? a : b;   //原始代码
            return 0;   //任何时候都返回0，则理论上任何时候都不应该通过测试
        }
```
经以上改动，如果测试方法是可靠测试，断言方法测对了地方，则应该永远无法通过测试。但测试结果显示`Max()`方法仍然通过，则说明断言方法测错了位置，我们应该判断`a`与`b`的大小而不是判断`_math`是否为空。

暂时想到这么多，最后更新2018/05/01
